#include common_scripts\utility;
#include maps\_utility;
#include maps\bots\_bot_utility;

/*
	Checks whether the path generated by the ASTAR path finding is inaccessible
*/
GetPathIsInaccessible( to, best_effort )
{
	if ( isDefined( best_effort ) )
	{
		path = generatePath( self.origin, to, self.team, level.bot_allowed_negotiation_links, best_effort );
	}
	else
	{
		path = generatePath( self.origin, to, self.team, level.bot_allowed_negotiation_links );
	}
	return !isDefined( path ) || ( path.size <= 0) ;
}

swap_array_index( array, index1, index2 )
{
	temp = array[ index1 ];
	array[ index1 ] = array[ index2 ];
	array[ index2 ] = temp;
	return array;
}

quickSort(array, compare_func, compare_func_arg1)
{
	return quickSortMid( array, 0, array.size - 1, compare_func, compare_func_arg1 );
}

/*
	Quicksort algorithm copied from T7 modified for T4
*/
quickSortMid( array, start, end, compare_func, compare_func_arg1 )
{
	i = start;
	k = end;

	if(!IsDefined(compare_func))
		compare_func = ::quicksort_compare;

	if (end - start >= 1)
	{
		pivot = array[start];

		while (k > i)
		{
			while ( [[ compare_func ]](array[i], pivot, compare_func_arg1) && i <= end && k > i)
				i++;
			while ( ![[ compare_func ]](array[k], pivot, compare_func_arg1) && k >= start && k >= i)
				k--;
			if (k > i)
				array = swap_array_index(array, i, k);
		}
		array = swap_array_index(array, start, k);
		array = quickSortMid(array, start, k - 1, compare_func);
		array = quickSortMid(array, k + 1, end, compare_func);
	}
	else
		return array;

	return array;
}

quicksort_compare(left, right, compare_func_arg1)
{
	return left <= right;
}

quicksort_compare_priority_field(left, right, compare_func_arg1)
{
	return left.priority <= right.priority;
}

quicksort_compare_pers_value_highest_to_lowest( left, right, compare_func_arg1 )
{
	return left.pers[ compare_func_arg1 ] <= right.pers[ compare_func_arg1 ];
}

quicksort_compare_pers_value_lowest_to_highest( left, right, compare_func_arg1 )
{
	return left.pers[ compare_func_arg1 ] >= right.pers[ compare_func_arg1 ];
}

assign_priority_to_powerup( powerup )
{
	if ( !isDefined( powerup ) )
	{
		return;
	}
	priority = 0;
	powerup_is_max_ammo = false;
	switch ( powerup.powerup_name )
	{
		case "zombie_blood":
		case "insta_kill":
		case "nuke":
			priority += 2;
			break;
		case "full_ammo":
			powerup_is_max_ammo = true;
			priority += 1;
			break;
		case "double_points":
		case "fire_sale":
		case "carpenter":
		case "free_perk":
			priority += 1;
			break;
		default:
			priority += 0;
			break;
	}
	if ( powerup_is_max_ammo )
	{
		LOW_AMMO_THRESHOLD = 0.3;

		players = getPlayers();

		for ( i = 0; i < players.size; i++ )
		{
			weapons = players[ i ] getWeaponsListPrimaries();
			for ( j = 0; j < weapons.size; j++ )
			{
				if ( players[ i ] getWeaponAmmoStock( weapons[ j ] ) <= int( weaponmaxammo( weapons[ j ] ) *  LOW_AMMO_THRESHOLD ) )
				{
					priority += 1;
					break;
				}
			}
			if ( priority > 3 )
			{
				break;
			}
		}
	}

	if ( maps\_laststand::player_any_player_in_laststand() )
	{
		switch ( powerup.powerup_name )
		{
			case "zombie_blood":
			case "insta_kill":
			case "nuke":
				priority += 1;
				break;
			case "full_ammo":
				priority += 0;
				break;
			case "double_points":
			case "fire_sale":
			case "carpenter":
			case "free_perk":
				priority -= 1;
				break;
			default:
				priority += 0;
				break;
		}
	}

	if ( powerup.time_left_until_timeout < 10.0 )
	{
		priority += 1;
	}
	if ( priority < 0 )
	{
		priority = 0;
	}
	powerup.priority = priority;
}

sort_array_by_priority_field( array, item )
{
	if ( isDefined( item ) )
	{
		array[ array.size ] = item;
	}

	array = quickSort( array, ::quicksort_compare_priority_field, undefined );
	return array;
}

get_players_sorted_by_highest_pers_value( pers_name )
{
	players = getPlayers();

	if ( !isDefined( players[ 0 ].pers[ pers_name ] ) )
	{
		assertMsg( "Uninitialized pers value: " + pers_name );
		return undefined;
	}

	return quickSort( players, ::quicksort_compare_pers_value_highest_to_lowest, pers_name );
}

get_players_sorted_by_lowest_pers_value( pers_name )
{
	players = getPlayers();

	if ( !isDefined( players[ 0 ].pers[ pers_name ] ) )
	{
		assertMsg( "Uninitialized pers value: " + pers_name );
		return undefined;
	}

	return quickSort( players, ::quicksort_compare_pers_value_lowest_to_highest, pers_name );
}

get_path_dist( start, end )
{
	path = generatePath( start, end, self.team, level.bot_allowed_negotiation_links, 192.0 );
	if ( !isDefined( path ) || path.size <= 0 )
	{
		return 9999999;
	}
	dist = 0;
	prev_node = undefined;
	for ( i = 0; i < path.size; i++ )
	{
		if ( i == 0 )
		{
			prev_node = path[ i ];
			continue;
		}
		dist += distance( prev_node.origin, path[ i ].origin );
		prev_node = path[ i ];
	}

	return dist;
}